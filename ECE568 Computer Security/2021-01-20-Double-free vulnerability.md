# 2021-01-20 Double-free vulnerability

* Freeing a memory location under control of an attacker is exploitable
```c
void *p = malloc(128);
void *q = malloc(128);

free(p);
free(q);
p = malloc(256);
strcpy(p, attacker_string); // just some normal string
free(q); // typo leading to vuln
``` 

* malloc implementation
  * double-linked list of free and allocated memory regions
  * info about region stored in chunk tag at beginning of allocated region
    * stores remaining space
    * stores free bit, indicating chunk is alloc'd or free
    * links to previous and next chunk tags
    * initially all one free region
  * when region is allocated, malloc makes a new tag with new free space, in doubly linked list
  * when region is freed, `free` sets the free bit, and consolidate adjacent regions by deleting the tag in the linked list
  * if attacker can write a fake tag, we can change memory values
* double free
  * when `free` is called on a region that contains hostile data we can manipulate memory
  * consider a freed tag `q` where `p < q < r`.
  * when we write something to `p` of size > `q`, we can write a fake chunk tag at the position that used to be `q - sizeof(Tag)`.
    * we write a fake tag where the prev pointer point to shellcode, and next pointer points to RA
    * `FakeTag = { .prev = &shellcode, .next = &RA }`
    * `fakeTag = q - sizeof(Tag)`
    * `fakeTag->next->prev = fakeTag->prev`
      * points RA to shellcode
* if address and control structures were not intermingled this would not be a vulnerability
