# 2019-11-25

* forall. x y $ on x y -> above x y
  * all members of on are subset of above

* forall x exists y (clear x or on y x)
  * x = a true
  * x = c true
* exists y forall x . clear x or on y x
  * y = a false (x = c)
  * y = c false (x = b)
  * ...
* kb is a set of formulae
  * i is a model of kb if every formula f in kb is true under i
  * i |= kb if i satisfies kb, or i |= f if f is true under i
* suppose f is not in kb, but is true in every model of kb. then i |=kb -> i |= f
  * f is a logical consequence of kb, or kb rntails f.
* elephant clyde 
  * clyde is a elephant
* teacup cup
  * cup is a teacup
* forall x y . elephant x and teacup y -> largerThan x y
  * then we have
    * forall x y . largerThan x y -> not  . fitsIn x y 
* we can now infer not . fitsIn clyde cup is true.
* this means (clyde, cup) is in the set of largerThan, which is a subset of not . fitsIn x y
* The more sentences in KB the fewer models there are
* the more you write down (assuming all sentences are true) the closer you get to the real world 
  * axiomatizing the domain
* we want a procedure to compute logical consequences
  * proof procedures
  * work by manipulating formulas, but respect semantics of interpretations
  
* Resolution
  * basis for prolog, theorem proving systems
  * we write KB |- f to indicate f can be proved from KB
    * only means my algo can spit out f, diff from |=
  * soundness
    * KB |- f -> KB |= f
      * all conclusions arrived at via the proof procedure are correct: they are logical consequences. proof procedure only generates true statements
    * KB |= f -> KB |- f
      * every logical consequence can be generated by the proof procedure
    * completeness is not necessary achievable in practice, complexity may be very hard.
* clausal form
  * resolution works with formulas expressed in clausal form
  * a literal is an atomic formula or the negation of an atomic formula
    * dog fido
    * not . cat fido
  * a clause is a disjunction of literals
    * not . owns fido fred or not . dog fido or person fred
    * we write (!owns(fido, fred), !dog(fido), person(fred))
  * a clausal theory is a conjunction of clauses
  * the resolution proof consists of only one 1 rule
    * for two clauses only 1 can be true
    * from 2 clauses
      * (P, Q1, Q2, ..., Qk)
      * (not P, R1, R2, ..., Rn)
      * (Q1, Q2, ..., R1, R2, ..., Rn)
    * since we have P and not P, they "cancel" out
    * For example
      * (not . largerThan clyde cup, not . fitsIn clyde cup)
      * (fitsIn clyde cup)
      * not . largerThan clyde cup
  * Forward chaining
    * If we have a sequence of clauses C1, C2, ..., Ck
    * such that each Ci is either in KB or the result of a resolution step involving two prior clauses
    * We have KB |- Ck
    * forward chaining is sound giving us KB |= Ck
* refutation
  * empty clause Cm is a contradiction
  * we determine KB |- f by showing contradition can be generated from KB and not . f
  * Construct a sequence of clauses
    * Ci in KB and not f is the result of resolving two previous clauses
      * Cm is the empty clause
    * trying to find a contradiction between KB and not . f
* ex want to prove `likes clyde peanuts` from
  * `elephant clyde, giraffe clyde`
  * `not . elephant, likes clyde peanuts`
  * `not . giraffe, likes clyde leaves`
  * `not . likes clyde leaves`
* forward chaining proof
  * 3 & 4 -> `not . giraffe clyde` (5)
    * we have contra 
  * 5 & 1 -> `elephant clyde` (6)
  * 6 & 2 -> `likes clyde peanuts`
    * contradiction of `elephant clyde` and `not . elephant clyde`
* Refutation proof
  * assume `not . likes clyde peanuts` (5)
  * 5 & 2 -> `not . elephant clyde` (6)
  * 6 & 1 -> `giraffe clyde` (7)
  * 7 & 3 -> `likes clyde leaves` (8)
  * 8 & 4 -> `()`
    * resolve 8 against `not . likes clyde leaves`
  * in this example we use clauses twice
* proofs by refutation are easier to find
  * more focused on the result
* to develop a complete proof procedure
  * way to convert KB and f to clausal form
  * way of doing resolution when we have variables
* convert KB to clausal form
  1. eliminate implications
     * a -> b == not . a or b 
  2. move negations inwards and simplify `not . not`
     * demorgans laws
  3. standardize variables
     * rename variables so each quantified variable is unique
  4. skolemization (remove existential quantifies by introducing new function symbols)
     * forall x . exists z == g(x)
     * consider `exists y . elephant y and friendly y`
       * some individual y that is both elephant and friendly
       * invent a name for this individual `a`. new constant symbol not equal to any previous constant symbol
       * `elephant a and friendly a`
       * we don't know anything about a. 
    * consider `forall x exists y. loves x y`
      * we can't just replace by a new constant
      * `forall x loves x a` is not the same, `a` becomes fixed.
      * we need functions, not just constants.
      * `forall x loves x $ g x`  where `g :: X -> Y`
      * we replace an existential by over all universals that scope the existential

